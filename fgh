#!/bin/bash
#
# fgh - finest-grained gh
#
# fgp プロキシの薄いクライアント。全てのコマンドを fgp の /cli エンドポイントに転送する。
#
# Usage:
#   fgh issue list
#   fgh pr view 123
#   fgh sub-issue list 123
#
# Environment:
#   FGP_PROXY_URL  - プロキシの URL (default: http://host.docker.internal:8766)
#

set -e

FGP_PROXY_URL="${FGP_PROXY_URL:-http://host.docker.internal:8766}"

# git remote から owner/repo を取得
get_repo_from_git() {
    local remote_url
    remote_url=$(git remote get-url origin 2>/dev/null) || return 1

    # パターン: github.com/owner/repo または host.docker.internal:8766/git/owner/repo
    if [[ "$remote_url" =~ github\.com[:/]([^/]+)/([^/.]+) ]]; then
        echo "${BASH_REMATCH[1]}/${BASH_REMATCH[2]}"
    elif [[ "$remote_url" =~ /git/([^/]+)/([^/.]+) ]]; then
        echo "${BASH_REMATCH[1]}/${BASH_REMATCH[2]}"
    fi
}

# API endpoint から owner/repo を取得
# 例: repos/owner/repo/issues -> owner/repo
get_repo_from_api_endpoint() {
    local endpoint="$1"
    if [[ "$endpoint" =~ ^/?repos/([^/]+)/([^/]+) ]]; then
        echo "${BASH_REMATCH[1]}/${BASH_REMATCH[2]}"
    fi
}

# -R/--repo オプションから owner/repo を取得
get_repo_from_args() {
    local args=("$@")
    for ((i=0; i<${#args[@]}; i++)); do
        if [[ "${args[i]}" == "-R" || "${args[i]}" == "--repo" ]]; then
            echo "${args[i+1]}"
            return
        fi
        if [[ "${args[i]}" =~ ^-R(.+)$ ]]; then
            echo "${BASH_REMATCH[1]}"
            return
        fi
        if [[ "${args[i]}" =~ ^--repo=(.+)$ ]]; then
            echo "${BASH_REMATCH[1]}"
            return
        fi
    done
}

# =============================================================================
# プロキシ経由の CLI 実行
# =============================================================================

# プロキシ経由で CLI コマンドを実行
call_proxy_cli() {
    local repo="$1"
    shift
    local args=("$@")

    # jq を使って安全に JSON を構築（NUL 区切りで改行を含む引数に対応）
    local args_json
    args_json=$(printf '%s\0' "${args[@]}" | jq -Rs 'split("\u0000") | map(select(length > 0))')

    local result
    result=$(curl -s -X POST "${FGP_PROXY_URL}/cli" \
        -H "Content-Type: application/json" \
        -d "$(jq -n --argjson args "$args_json" --arg repo "$repo" '{args: $args, repo: $repo}')")

    # エラーチェック（HTML エラーページ）
    if echo "$result" | grep -q '<!DOCTYPE'; then
        echo "$result" | grep -oP '(?<=<p>Message: ).*(?=</p>)' >&2
        return 1
    fi

    # exit_code をチェック
    local exit_code
    exit_code=$(echo "$result" | jq -r '.exit_code')
    local stdout
    stdout=$(echo "$result" | jq -r '.stdout')
    local stderr
    stderr=$(echo "$result" | jq -r '.stderr')

    if [[ "$exit_code" != "0" ]]; then
        echo "$stderr" >&2
        return "$exit_code"
    fi

    # gh outputs success messages to stderr (UNIX convention)
    if [[ -n "$stderr" ]]; then
        echo "$stderr" >&2
    fi
    if [[ -n "$stdout" ]]; then
        echo "$stdout"
    fi
}

# =============================================================================
# auth コマンド
# =============================================================================

show_auth_help() {
    cat <<'EOF'
Display authentication status for fgp proxy.

USAGE
  fgh auth <command>

COMMANDS
  status:     Show authentication status for all PATs

EXAMPLES
  fgh auth status
EOF
}

handle_auth() {
    local action="$1"

    if [[ -z "$action" || "$action" == "--help" || "$action" == "-h" ]]; then
        show_auth_help
        return 0
    fi

    # Check for --help anywhere in args
    for arg in "$@"; do
        if [[ "$arg" == "--help" || "$arg" == "-h" ]]; then
            show_auth_help
            return 0
        fi
    done

    if [[ "$action" != "status" ]]; then
        echo "Unknown command: $action" >&2
        echo "Run 'fgh auth --help' for usage." >&2
        return 1
    fi

    # Call /auth/status endpoint
    local result
    result=$(curl -s "${FGP_PROXY_URL}/auth/status")

    if [[ -z "$result" ]]; then
        echo "Error: Could not connect to fgp proxy at ${FGP_PROXY_URL}" >&2
        return 1
    fi

    # Check for HTML error response
    if echo "$result" | grep -q '<!DOCTYPE'; then
        echo "Error: Proxy returned an error" >&2
        return 1
    fi

    # Format and display the result
    echo ""

    # Check if new format (pats array) or legacy format
    local pats_count
    pats_count=$(echo "$result" | jq '.pats | length // 0')

    if [[ "$pats_count" -gt 0 ]]; then
        # New format: pats array
        echo "PATs configured: $pats_count"
        echo ""

        for ((i=0; i<pats_count; i++)); do
            local pat_valid
            pat_valid=$(echo "$result" | jq -r ".pats[$i].valid")
            local pat_masked
            pat_masked=$(echo "$result" | jq -r ".pats[$i].masked_token")
            local pat_repos
            pat_repos=$(echo "$result" | jq -r ".pats[$i].repos | join(\", \")")
            local pat_user
            pat_user=$(echo "$result" | jq -r ".pats[$i].user // empty")

            if [[ "$pat_valid" == "true" ]]; then
                echo "  ✓ [$i] $pat_masked"
                if [[ -n "$pat_user" ]]; then
                    echo "      User: $pat_user"
                fi
                if [[ -n "$pat_repos" ]]; then
                    echo "      Repos: $pat_repos"
                fi
            else
                local pat_error
                pat_error=$(echo "$result" | jq -r ".pats[$i].error // \"Unknown error\"")
                echo "  ✗ [$i] $pat_masked"
                if [[ -n "$pat_repos" ]]; then
                    echo "      Repos: $pat_repos"
                fi
                echo "      Error: $pat_error"
            fi
        done
    else
        # Legacy format: classic_pat + fine_grained_pats
        echo "Classic PAT:"
        local classic_valid
        classic_valid=$(echo "$result" | jq -r '.classic_pat.valid')
        local classic_masked
        classic_masked=$(echo "$result" | jq -r '.classic_pat.masked_token')
        local classic_user
        classic_user=$(echo "$result" | jq -r '.classic_pat.user // empty')

        if [[ "$classic_valid" == "true" ]]; then
            echo "  ✓ Valid ($classic_masked)"
            echo "    User: $classic_user"
            local scopes
            scopes=$(echo "$result" | jq -r '.classic_pat.scopes | join(", ")')
            if [[ -n "$scopes" ]]; then
                echo "    Scopes: $scopes"
            fi
        else
            local error
            error=$(echo "$result" | jq -r '.classic_pat.error // "Unknown error"')
            echo "  ✗ Invalid ($classic_masked)"
            echo "    Error: $error"
        fi

        # Fine-grained PATs
        local fg_count
        fg_count=$(echo "$result" | jq '.fine_grained_pats | length')

        if [[ "$fg_count" -gt 0 ]]; then
            echo ""
            echo "Fine-grained PATs:"

            for ((i=0; i<fg_count; i++)); do
                local fg_valid
                fg_valid=$(echo "$result" | jq -r ".fine_grained_pats[$i].valid")
                local fg_masked
                fg_masked=$(echo "$result" | jq -r ".fine_grained_pats[$i].masked_token")
                local fg_repos
                fg_repos=$(echo "$result" | jq -r ".fine_grained_pats[$i].repos | join(\", \")")

                if [[ "$fg_valid" == "true" ]]; then
                    local fg_user
                    fg_user=$(echo "$result" | jq -r ".fine_grained_pats[$i].user // empty")
                    echo "  ✓ Valid ($fg_masked)"
                    if [[ -n "$fg_user" ]]; then
                        echo "    User: $fg_user"
                    fi
                    if [[ -n "$fg_repos" ]]; then
                        echo "    Repos: $fg_repos"
                    fi
                else
                    local fg_error
                    fg_error=$(echo "$result" | jq -r ".fine_grained_pats[$i].error // \"Unknown error\"")
                    echo "  ✗ Invalid ($fg_masked)"
                    if [[ -n "$fg_repos" ]]; then
                        echo "    Repos: $fg_repos"
                    fi
                    echo "    Error: $fg_error"
                fi
            done
        fi
    fi

    echo ""
}

# =============================================================================
# discussion コマンド
# =============================================================================

show_discussion_help() {
    cat <<'EOF'
Work with GitHub Discussions.

USAGE
  fgh discussion <command> [flags]

COMMANDS
  list:             List discussions in a repository
  view:             View a discussion
  create:           Create a new discussion
  edit:             Edit a discussion
  close:            Close a discussion
  reopen:           Reopen a discussion
  delete:           Delete a discussion
  comment:          Add a comment to a discussion
  comment edit:     Edit a discussion comment (by ID)
  comment delete:   Delete a discussion comment (by ID)
  answer:           Mark a comment as the answer (Q&A only)
  unanswer:         Unmark a comment as the answer (Q&A only)
  poll vote:        Vote on a discussion poll (Polls only)

FLAGS
  -R, --repo <owner/repo>   Specify repository (default: from git remote)
  -t, --title <text>        Title (for create/edit)
  -b, --body <text>         Body text
  -c, --category <name>     Category name (for create)
  --reply-to <comment_id>   Reply to a comment (for comment)

EXAMPLES
  fgh discussion list
  fgh discussion view 123
  fgh discussion create --title "Feature request" --body "..." --category "Ideas"
  fgh discussion edit 123 --body "Updated body"
  fgh discussion close 123
  fgh discussion reopen 123
  fgh discussion delete 123
  fgh discussion comment 123 --body "My comment"
  fgh discussion comment edit DC_xxx --body "Updated comment"
  fgh discussion comment delete DC_xxx
  fgh discussion answer DC_xxx
  fgh discussion unanswer DC_xxx
  fgh discussion poll vote PO_xxx
EOF
}

handle_discussion() {
    local action="$1"

    if [[ -z "$action" || "$action" == "--help" || "$action" == "-h" ]]; then
        show_discussion_help
        return 0
    fi

    # Check for --help anywhere in args
    for arg in "$@"; do
        if [[ "$arg" == "--help" || "$arg" == "-h" ]]; then
            show_discussion_help
            return 0
        fi
    done

    shift

    # repo を取得
    local repo
    repo=$(get_repo_from_args "$@")
    if [[ -z "$repo" ]]; then
        repo=$(get_repo_from_git)
    fi

    if [[ -z "$repo" ]]; then
        echo "Error: Could not determine repository. Use -R owner/repo" >&2
        return 1
    fi

    # -R を除いた引数を取得
    local args=()
    local skip_next=false
    for arg in "$@"; do
        if $skip_next; then
            skip_next=false
            continue
        fi
        if [[ "$arg" == "-R" || "$arg" == "--repo" ]]; then
            skip_next=true
            continue
        fi
        if [[ "$arg" =~ ^-R || "$arg" =~ ^--repo= ]]; then
            continue
        fi
        args+=("$arg")
    done

    # プロキシに転送
    call_proxy_cli "$repo" "discussion" "$action" "${args[@]}"
}

# =============================================================================
# sub-issue コマンド
# =============================================================================

# sub-issue コマンドのヘルプ
show_sub_issue_help() {
    cat <<'EOF'
Work with GitHub sub-issues.

USAGE
  fgh sub-issue <command> [flags]

COMMANDS
  list:     List sub-issues of an issue
  add:      Add a sub-issue to an issue
  remove:   Remove a sub-issue from an issue
  parent:   Show parent issue
  reorder:  Reorder sub-issues

FLAGS
  -R, --repo <owner/repo>   Specify repository (default: from git remote)

EXAMPLES
  fgh sub-issue list 123
  fgh sub-issue add 100 123
  fgh sub-issue parent 123
EOF
}

# sub-issue コマンドのメイン
handle_sub_issue() {
    local action="$1"

    # 引数なしまたは --help ならヘルプ表示
    if [[ -z "$action" || "$action" == "--help" || "$action" == "-h" ]]; then
        show_sub_issue_help
        return 0
    fi

    # Check for --help anywhere in args
    for arg in "$@"; do
        if [[ "$arg" == "--help" || "$arg" == "-h" ]]; then
            show_sub_issue_help
            return 0
        fi
    done

    shift

    # repo を取得
    local repo
    repo=$(get_repo_from_args "$@")
    if [[ -z "$repo" ]]; then
        repo=$(get_repo_from_git)
    fi

    if [[ -z "$repo" ]]; then
        echo "Error: Could not determine repository. Use -R owner/repo" >&2
        return 1
    fi

    # -R を除いた引数を取得
    local args=()
    local skip_next=false
    for arg in "$@"; do
        if $skip_next; then
            skip_next=false
            continue
        fi
        if [[ "$arg" == "-R" || "$arg" == "--repo" ]]; then
            skip_next=true
            continue
        fi
        if [[ "$arg" =~ ^-R || "$arg" =~ ^--repo= ]]; then
            continue
        fi
        args+=("$arg")
    done

    # 引数バリデーションとプロキシ呼び出し
    case "$action" in
        list)
            local issue_number="${args[0]}"
            if [[ -z "$issue_number" ]]; then
                echo "accepts 1 arg(s), received 0" >&2
                return 1
            fi
            call_proxy_cli "$repo" "sub-issue" "list" "$issue_number"
            ;;
        add)
            local parent="${args[0]}"
            local child="${args[1]}"
            local received=${#args[@]}
            if [[ $received -lt 2 ]]; then
                echo "accepts 2 arg(s), received $received" >&2
                return 1
            fi
            call_proxy_cli "$repo" "sub-issue" "add" "$parent" "$child"
            ;;
        remove)
            local parent="${args[0]}"
            local child="${args[1]}"
            local received=${#args[@]}
            if [[ $received -lt 2 ]]; then
                echo "accepts 2 arg(s), received $received" >&2
                return 1
            fi
            call_proxy_cli "$repo" "sub-issue" "remove" "$parent" "$child"
            ;;
        parent)
            local child="${args[0]}"
            if [[ -z "$child" ]]; then
                echo "accepts 1 arg(s), received 0" >&2
                return 1
            fi
            call_proxy_cli "$repo" "sub-issue" "parent" "$child"
            ;;
        reorder)
            local parent="${args[0]}"
            local child="${args[1]}"
            local received=${#args[@]}
            if [[ $received -lt 2 ]]; then
                echo "accepts 2 arg(s), received $received" >&2
                return 1
            fi
            # --before/--after を探して proxy に渡す
            local reorder_args=("sub-issue" "reorder" "$parent" "$child")
            local i=2
            while [[ $i -lt ${#args[@]} ]]; do
                reorder_args+=("${args[i]}")
                i=$((i + 1))
            done
            call_proxy_cli "$repo" "${reorder_args[@]}"
            ;;
        *)
            echo "unknown command: $action" >&2
            return 1
            ;;
    esac
}

# メインヘルプ表示
show_main_help() {
    cat <<'EOF'
fgh - finest-grained gh

USAGE
  fgh <command> [args...]

COMMANDS
  auth        Manage authentication state
  discussion  Work with discussions (custom implementation)
  issue       Work with issues (via gh)
  pr          Work with pull requests (via gh)
  sub-issue   Work with sub-issues (custom implementation)

Run 'fgh <command> --help' for more information on a command.
All commands are forwarded to fgp proxy for permission checking.
EOF
}

# メイン
main() {
    if [[ $# -eq 0 || "$1" == "--help" || "$1" == "-h" ]]; then
        show_main_help
        return 0
    fi

    local subcommand="$1"

    # auth コマンドは特別扱い（プロキシに直接問い合わせ）
    if [[ "$subcommand" == "auth" ]]; then
        shift
        handle_auth "$@"
        return
    fi

    # discussion コマンドは特別扱い（GraphQL カスタムコマンド）
    if [[ "$subcommand" == "discussion" ]]; then
        shift
        handle_discussion "$@"
        return
    fi

    # sub-issue コマンドは特別扱い（引数バリデーション + ヘルプ）
    if [[ "$subcommand" == "sub-issue" ]]; then
        shift
        handle_sub_issue "$@"
        return
    fi

    # issue/pr の引数なし or --help は gh に直接流す
    if [[ "$subcommand" == "issue" || "$subcommand" == "pr" ]]; then
        local second_arg="$2"
        if [[ -z "$second_arg" || "$second_arg" == "--help" || "$second_arg" == "-h" ]]; then
            gh "$subcommand" --help
            return
        fi
        # Check for --help anywhere in args
        for arg in "$@"; do
            if [[ "$arg" == "--help" || "$arg" == "-h" ]]; then
                gh "$subcommand" --help
                return
            fi
        done
    fi

    # owner/repo を取得
    local repo

    # api コマンドの場合は endpoint から repo を抽出（優先）
    if [[ "$subcommand" == "api" ]]; then
        local endpoint="$2"

        # graphql は禁止
        if [[ "$endpoint" == "graphql" ]]; then
            echo "Error: GraphQL API is not supported. Use high-level commands (issue, pr, discussion, sub-issue) instead." >&2
            return 1
        fi

        # endpoint から repo を抽出
        if [[ -n "$endpoint" ]]; then
            repo=$(get_repo_from_api_endpoint "$endpoint")
        fi
    fi

    # -R オプションから取得
    if [[ -z "$repo" ]]; then
        repo=$(get_repo_from_args "$@")
    fi

    # git remote から取得
    if [[ -z "$repo" ]]; then
        repo=$(get_repo_from_git)
    fi

    if [[ -z "$repo" ]]; then
        echo "Error: Could not determine repository. Use -R owner/repo" >&2
        return 1
    fi

    # --body-file / -F をファイル内容に変換（fgp 側にファイルがないため）
    local args=()
    local skip_next=false
    for ((i=1; i<=$#; i++)); do
        if $skip_next; then
            skip_next=false
            continue
        fi
        local arg="${!i}"
        local next_i=$((i + 1))
        local next_arg="${!next_i}"

        if [[ "$arg" == "--body-file" || "$arg" == "-F" ]]; then
            if [[ -z "$next_arg" ]]; then
                echo "Error: $arg requires a file path" >&2
                return 1
            fi
            if [[ ! -f "$next_arg" ]]; then
                echo "Error: File not found: $next_arg" >&2
                return 1
            fi
            local content
            content=$(cat "$next_arg")
            args+=("--body" "$content")
            skip_next=true
        elif [[ "$arg" =~ ^--body-file=(.+)$ ]]; then
            local filepath="${BASH_REMATCH[1]}"
            if [[ ! -f "$filepath" ]]; then
                echo "Error: File not found: $filepath" >&2
                return 1
            fi
            local content
            content=$(cat "$filepath")
            args+=("--body" "$content")
        elif [[ "$arg" =~ ^-F(.+)$ ]]; then
            local filepath="${BASH_REMATCH[1]}"
            if [[ ! -f "$filepath" ]]; then
                echo "Error: File not found: $filepath" >&2
                return 1
            fi
            local content
            content=$(cat "$filepath")
            args+=("--body" "$content")
        else
            args+=("$arg")
        fi
    done

    # pr create の場合、--head を自動付与（fgp 側で origin 解決できないため）
    if [[ "${args[0]}" == "pr" && "${args[1]}" == "create" ]]; then
        # --head が既に指定されているかチェック
        local has_head=false
        for arg in "${args[@]}"; do
            if [[ "$arg" == "--head" || "$arg" =~ ^--head= ]]; then
                has_head=true
                break
            fi
        done

        if ! $has_head; then
            local branch
            branch=$(git branch --show-current 2>/dev/null)
            if [[ -n "$branch" ]]; then
                local owner="${repo%%/*}"
                args+=("--head" "${owner}:${branch}")
            fi
        fi
    fi

    # 全てのコマンドを fgp に転送
    call_proxy_cli "$repo" "${args[@]}"
}

main "$@"
